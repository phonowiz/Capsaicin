#define USE_INLINE_RT 1
#include "nrc_path_tracer.comp"
#include "nrc_path_tracing.hlsl"

TriangleHitGroup NRCHitGroup =
{
    "NRCPTAnyHit", 
    "NRCPTClosestHit", 
};

TriangleHitGroup NRCShadowHitGroup =
{
    "NRCPTShadowAnyHit", 
    "", 
};

RaytracingShaderConfig NRCShaderConfig =
{
    sizeof(PathData), // max payload size
    sizeof(BuiltInTriangleIntersectionAttributes) // max attribute size
};

RaytracingPipelineConfig NRCPipelineConfig =
{
    2 // max trace recursion depth
};


[shader("raygeneration")]
void NRCPTRaygen()
{
    uint2 did = DispatchRaysIndex().xy;
    uint2 dimensions = g_BufferDimensions;
    
    // Check if valid pixel
    if (any(did >= dimensions)) return;

    // Standard camera ray generation
    const uint id = did.x + did.y * dimensions.x;
    const uint frameID = g_FrameIndex;
    Random randomNG = MakeRandom(id, frameID);
    
    // Stratified sampling
    StratifiedSampler randomStratified = MakeStratifiedSampler(id, frameID);
    
    // Ray
    float2 pixelRay = float2(did) + 0.5f;
    RayInfo ray = generateCameraRay(pixelRay, g_RayCamera);

    float3 radiance = 0.0f;
    
    // Training Ray Check: 1 in N pixels? Or random?
    // Let's do 1% of rays are training rays.
    bool isTraining = (randomNG.rand() < 0.03f);

    tracePathNRC(ray, randomStratified, randomNG, 0, g_BounceRRCount, g_BounceCount, 0.0f.xxx, 1.0f.xxx, radiance, isTraining, did);

    // if(isTraining)
    // {
    //     g_OutputBuffer[did] = float4(100.f, 0.f, 100.f, 1.0f);
    // }
    // else
    {
        g_OutputBuffer[did] = float4(radiance, 1.0f);
    }
}

[shader("miss")]
void NRCPTMiss(inout PathData path)
{
    pathMiss(path);
}

[shader("anyhit")]
void NRCPTAnyHit(inout PathData path, in BuiltInTriangleIntersectionAttributes attr)
{
    pathAnyHit(attr);
}

[shader("closesthit")]
void NRCPTClosestHit(inout PathData path, in BuiltInTriangleIntersectionAttributes attr)
{
    const uint minBounces = g_BounceRRCount; 
    const uint maxBounces = g_BounceCount;
    pathClosestHit(path, attr, minBounces, maxBounces);
}

// Shadow shaders
[shader("miss")]
void NRCPTShadowMiss(inout ShadowRayPayload payload) { payload.visible = true; }
[shader("anyhit")]
void NRCPTShadowAnyHit(inout ShadowRayPayload payload, in BuiltInTriangleIntersectionAttributes attr) { pathShadowAnyHit(attr); }
