/**********************************************************************
Copyright (c) 2025 Advanced Micro Devices, Inc. All rights reserved.
********************************************************************/

#include "nrc_common.hlsl"

typedef half float16_t;
typedef half2 float16_t2;

#define LAYER_WIDTH_HALVES 32   
#define THREAD_NEURONS_HALVES 8   
#define BLOCK_PIXELS 128        

ConstantBuffer<NRCConstants> g_NRCConstants : register(b0);

// SRVs
StructuredBuffer<InferenceQuery> g_InferenceQueries : register(t0);
StructuredBuffer<float16_t2> g_Weights : register(t1);
StructuredBuffer<uint> g_Counters : register(t3);

// UAVs
RWTexture2D<float4> g_OutputTexture : register(u1);
RWStructuredBuffer<float16_t2> g_Activations : register(u2);

groupshared float16_t2 s_activations[LAYER_WIDTH_HALVES][BLOCK_PIXELS];
groupshared float16_t2 s_weights[LAYER_WIDTH_HALVES * 64];

[numthreads(BLOCK_PIXELS, 1, 1)]
void NRCInference(uint3 dtid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID)
{
    const uint pixel_in_block = gtid.x;
    const uint warp_id = gtid.x / 32;
    const uint global_pixel_idx = dtid.x;

    uint count = g_Counters[g_NRCConstants.is_training_pass];
    // if (global_pixel_idx >= count)
    //     return;

    InferenceQuery query = g_InferenceQueries[global_pixel_idx];
    
    // 1. Encode Input
    float activations_f[NETWORK_WIDTH];
    EncodeInputs(query, activations_f);
    
    [unroll]
    for (int i = 0; i < LAYER_WIDTH_HALVES; i++)
    {
        s_activations[i][pixel_in_block] = float16_t2((float16_t) activations_f[i * 2], (float16_t) activations_f[i * 2 + 1]);
    }

    // --- MLP Hidden Layers (0 to 6) ---
    [loop]
    for (int layer = 0; layer < 6; layer++)
    {
        // LOG ACTIVATIONS: Only do this for training samples to save bandwidth!
        if (g_NRCConstants.is_training_pass)
        {
            for (int k = 0; k < LAYER_WIDTH_HALVES; k++)
            {
                uint act_idx = (layer * g_NRCConstants.activations_stride + g_NRCConstants.activations_offset + global_pixel_idx) * LAYER_WIDTH_HALVES + k;
                g_Activations[act_idx] = s_activations[k][pixel_in_block];
            }
        }

        const int LAYER_WEIGHT_STRIDE = NETWORK_WIDTH * LAYER_WIDTH_HALVES;
        
        // Cooperative Weight Load
        [unroll]
        for (int j = 0; j < 16; j++)
        {
            int w_idx = j * BLOCK_PIXELS + pixel_in_block;
            s_weights[w_idx] = g_Weights[layer * LAYER_WEIGHT_STRIDE + w_idx];
        }
        GroupMemoryBarrierWithGroupSync();

        float16_t2 my_results[THREAD_NEURONS_HALVES];
        [unroll]
        for (int out_pair = 0; out_pair < THREAD_NEURONS_HALVES; out_pair++)
        {
            float16_t2 sum2 = (float16_t2) 0.0;
            int row_index = (warp_id * THREAD_NEURONS_HALVES) + out_pair;

            [unroll]
            for (int in_pair = 0; in_pair < LAYER_WIDTH_HALVES; in_pair++)
            {
                sum2 += s_activations[in_pair][pixel_in_block] * s_weights[row_index * LAYER_WIDTH_HALVES + in_pair];
            }
            my_results[out_pair] = max(sum2, (float16_t2) 0.0); // ReLU
        }

        GroupMemoryBarrierWithGroupSync();
        [unroll]
        for (int out_p = 0; out_p < THREAD_NEURONS_HALVES; out_p++)
        {
            int r_idx = (warp_id * THREAD_NEURONS_HALVES) + out_p;
            s_activations[r_idx][pixel_in_block] = my_results[out_p];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // --- 2. Final Output Layer Reduction (64 -> 3) ---
    // At this point, s_activations contains the final hidden layer (64 units).
    // We now multiply by the last weight matrix (64x3).
    float3 radiance_pred = float3(0, 0, 0);
    const int FINAL_LAYER_W_OFFSET = 6 * (NETWORK_WIDTH * LAYER_WIDTH_HALVES);

    [unroll]
    for (int i = 0; i < LAYER_WIDTH_HALVES; i++)
    {
        float16_t2 act = s_activations[i][pixel_in_block];
        
        // Final layer weights: 3 neurons (R, G, B), each having 64 float16_t2 weights
        radiance_pred.r += (float) dot(act, g_Weights[FINAL_LAYER_W_OFFSET + 0 * LAYER_WIDTH_HALVES + i]);
        radiance_pred.g += (float) dot(act, g_Weights[FINAL_LAYER_W_OFFSET + 1 * LAYER_WIDTH_HALVES + i]);
        radiance_pred.b += (float) dot(act, g_Weights[FINAL_LAYER_W_OFFSET + 2 * LAYER_WIDTH_HALVES + i]);
    }

    // Standard Radiance output clamping
    radiance_pred = max(0.0f, radiance_pred);
    
    // --- 3. Radiance Reconstruction ---
    // L_total = L_direct + Throughput * (Albedo * Pred)
    float3 l_indirect = (radiance_pred * query.albedo.rgb);// * query.throughput.rgb;
    
    // Read previous direct/short-path radiance from the output texture
    float3 direct_radiance = g_OutputTexture[query.pixel_coord].rgb;
    
    // Reconstruct final pixel value
    float3 final_radiance = direct_radiance + l_indirect;
    
    g_OutputTexture[query.pixel_coord] = float4(20.0f, 20.0f, 20.0f, 1.0f);
}
