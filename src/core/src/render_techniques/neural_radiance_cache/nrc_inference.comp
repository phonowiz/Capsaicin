/**********************************************************************
Copyright (c) 2025 Advanced Micro Devices, Inc. All rights reserved.
********************************************************************/

#include "nrc_common.hlsl"

// Enable 16-bit types
typedef half  float16_t;
typedef half2 float16_t2;

#define LAYER_WIDTH_HALVES 32   
#define THREAD_NEURONS_HALVES 8   
#define BLOCK_PIXELS 128        

ConstantBuffer<NRCConstants> g_NRCConstants : register(b0);

// SRVs
StructuredBuffer<InferenceQuery> g_InferenceQueries : register(t0);
StructuredBuffer<float16_t2>    g_Weights          : register(t1);
StructuredBuffer<uint>           g_Counters         : register(t3);

// UAVs
RWTexture2D<float4>            g_OutputTexture      : register(u1);
RWStructuredBuffer<float16_t2> g_Activations        : register(u2);
RWTexture2D<float4>            g_AccumulationBuffer : register(u6);

groupshared float16_t2 s_activations[LAYER_WIDTH_HALVES][BLOCK_PIXELS];
groupshared float16_t2 s_weights[LAYER_WIDTH_HALVES * 64];

[numthreads(BLOCK_PIXELS, 1, 1)]
void NRCInference(uint3 dtid : SV_DispatchThreadID, uint3 gtid : SV_GroupThreadID)
{
    const uint pixel_in_block = gtid.x;
    const uint warp_id = gtid.x / 32;
    const uint global_pixel_idx = dtid.x;

    uint count = g_Counters[0];
    if (global_pixel_idx >= count)
        return;

    InferenceQuery query = g_InferenceQueries[global_pixel_idx];
    
    // 1. Encode Input
    float activations_f[NETWORK_WIDTH];
    EncodeInputs(query, activations_f);
    
    // Store initial encoded features into Shared Memory
    [unroll]
    for (int i = 0; i < LAYER_WIDTH_HALVES; i++)
    {
        s_activations[i][pixel_in_block] = float16_t2(
            (float16_t)activations_f[i * 2], 
            (float16_t)activations_f[i * 2 + 1]
        );
    }

    // --- MLP Layers ---
    [loop]
    for (int layer = 0; layer < 7; layer++)
    {
        // A. LOG ACTIVATIONS (Before they are overwritten by matrix multiply)
        for (int k = 0; k < LAYER_WIDTH_HALVES; k++)
        {
            uint act_idx = (layer * g_NRCConstants.activations_stride + g_NRCConstants.activations_offset + global_pixel_idx) * LAYER_WIDTH_HALVES + k;
            g_Activations[act_idx] = s_activations[k][pixel_in_block];
        }

        const int LAYER_WEIGHT_STRIDE = NETWORK_WIDTH * LAYER_WIDTH_HALVES;
        // B. Cooperative Weight Load
        [unroll]
        for (int j = 0; j < 16; j++)
        {
            int w_idx = j * BLOCK_PIXELS + pixel_in_block;
            s_weights[w_idx] = g_Weights[layer * LAYER_WEIGHT_STRIDE + w_idx];
        }
        GroupMemoryBarrierWithGroupSync();

        // C. Compute (Fused half2 Multiply-Accumulate)
        float16_t2 my_results[THREAD_NEURONS_HALVES]; 
        [unroll]
        for (int out_pair = 0; out_pair < THREAD_NEURONS_HALVES; out_pair++)
        {
            float16_t2 sum2 = (float16_t2)0.0;
            int row_index = (warp_id * THREAD_NEURONS_HALVES) + out_pair;

            [unroll]
            for (int in_pair = 0; in_pair < LAYER_WIDTH_HALVES; in_pair++)
            {
                sum2 += s_activations[in_pair][pixel_in_block] * s_weights[row_index * LAYER_WIDTH_HALVES + in_pair];
            }
            // ReLU
            my_results[out_pair] = max(sum2, (float16_t2)0.0);
        }

        // D. Hand-off (Write the new activations for the next loop/layer)
        GroupMemoryBarrierWithGroupSync();
        [unroll]
        for (int out_p = 0; out_p < THREAD_NEURONS_HALVES; out_p++)
        {
            int r_idx = (warp_id * THREAD_NEURONS_HALVES) + out_p;
            s_activations[r_idx][pixel_in_block] = my_results[out_p];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if(warp_id == 0)
    {
        // 3. Final Write-out (Reducing 64 neurons to RGB and Factorizing)
        float16_t2 rg_raw = s_activations[0][pixel_in_block];
        float16_t  b_raw  = s_activations[1][pixel_in_block].x;

        float3 radiance_pred = float3((float)rg_raw.x, (float)rg_raw.y, (float)b_raw);
        radiance_pred = max(0.0f, radiance_pred);
        
        // Follow paper: L_total = L_direct + Throughput * (Albedo * Pred)
        float3 l_indirect = (radiance_pred * query.albedo.rgb) * query.throughput.rgb;
        
        // Pull current direct lighting from accumulation buffer
        float4 acc = g_AccumulationBuffer[query.pixel_coord];
        uint sample_count = asuint(acc.w);
        
        if (sample_count > 0)
        {
            // Add the weighted indirect contribution to the running average
            float3 final_radiance = acc.xyz + (l_indirect / (float)sample_count);
            
            // Update the persistent memory (Source of Truth)
            g_AccumulationBuffer[query.pixel_coord] = float4(final_radiance, asfloat(sample_count));
            
            // Update the display (Screen)
            g_OutputTexture[query.pixel_coord] = float4(final_radiance, 1.0f);
        }
    }
}
